<html>
<head>


<meta http-equiv="cache-control" content="max-age=0" />
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="expires" content="0" />
<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
<meta http-equiv="pragma" content="no-cache" />


<meta charset="UTF-8">
<style type="text/css">
table, th, td {
   border-width: 1px;
   border-style: solid;
   border-collapse: collapse;
   text-align:center;
   padding: 1px 5px 1px 5px;
}
th {
   background-color: lightyellow;
}
th.thh {
   background-color: lightcyan;
}
th.ths, th.thsa {
   border-top-width: 2px;
   font-style: italic;
/*   background-color: #FFF8DC; */
   font-weight: bold;
/*#FCDFFF;*/
}
th.thsa {
   border-left-width: 2px;
   border-right-width: 2px;
   background-color: lightyellow;
}
th.arch {
   border-top-width: 2px;
   font-style: italic;
   font-weight: normal;
}
th.direction {
   font-weight: normal;
}
td.best {
/*   background-color: #D8FBD8; */
}
td.algorithm {
   border-left-width: 2px;
   border-right-width: 2px;
   background-color: lightyellow;
}
.left {
   border-left-width: 2px;
}
.top {
   border-top-width: 2px;
}
.bottom {
   border-bottom-width: 2px;
}
.right {
   border-right-width: 2px;
}
td.descr {
/*   text-align: left; */
}
span.toc {
   margin-right: 20px;
   white-space: nowrap;
}
</style>
</head>
<body>
<h1>cppcrypto library</h1>
<p>
<span class="toc"><a href="#chintro">1. Introduction</a></span>
<span class="toc"><a href="#chha">2. Hash algorithms</a></span>
<span class="toc"><a href="#chmac">3. MAC algorithms</a></span>
<span class="toc"><a href="#chbc">4. Block cipher algorithms</a></span>
<span class="toc"><a href="#chem">5. Block cipher encryption modes</a></span>
<span class="toc"><a href="#chsc">6. Stream cipher algorithms</a></span>
<span class="toc"><a href="#chkdf">7. Key derivation functions</a></span>
<span class="toc"><a href="#chdu">8. Digest utility</a></span>
<span class="toc"><a href="#chcryptor">9. Cryptor utility</a></span>
<span class="toc"><a href="#chpn">10. Portability notes</a></span>
<span class="toc"><a href="#chdl">11. Download link</a></span>
</p>
<h2 id="chintro">1. Introduction</h2>
<p>cppcrypto is a small cross-platform BSD-licensed C++ library providing some cryptographic primitives. It has no external dependencies.</p>
<p>The library thrives to be as fast as possible. CPU type is detected at runtime and the fastest implementation is selected dynamically.</p>
<p><b>Supported compilers:</b> Visual C++ 2013 or later on Windows; gcc 5.1.1 or later, clang 3.4.1 or later on Linux, OS X, FreeBSD; Solaris Studio 12.4 or later on Solaris.
<br><b>Supported architectures:</b> x86_64 and x86.</p>
<p><a href="https://sourceforge.net/projects/cppcrypto/files">Download cppcrypto from sourceforge</a></p>
<p>Full list of supported cryptographic primitives is described below.
<h2 id="chha">2. Hash algorithms</h2>
<h3>2.1. Interface description</h3>
<p>All hash algorithms derive from <code>crypto_hash</code> class and implement its interface.</p>
<pre>
    class crypto_hash
    {
    public:
        virtual void init() = 0;
        virtual void update(const unsigned char* data, size_t len) = 0;
        virtual void final(unsigned char* hash) = 0;

        virtual size_t hashsize() const = 0;
        virtual size_t blocksize() const = 0;

        // Convenience functions
        void hash_string(const unsigned char* data, size_t len, unsigned char* hash);
        void hash_string(const char* data, size_t len, unsigned char* hash);
        void hash_string(const std::string& data, unsigned char* hash);
    };
</pre>
<p>If you have a short message, you can calculate the hash using a single <code>hash_string()</code> call.
Otherwise, call <code>init()</code> to start hashing,
then call <code>update()</code> any number of times to add the next chunk of data, and finally call <code>final()</code> to get the hash.
<br>The <code>hash</code> parameter should point to a buffer large enough to accept the hash of correspondent size (length in bytes is <code>hashsize()/8</code>).</p>
<h3>2.2. Supported algorithms</h3>
<p>Classes derived from <code>crypto_hash</code>:</p>
<table>
<tr><th>Class Name</th><th>Description</th><th>Supported output sizes</th></tr>
<tr>
<td><code>blake</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/BLAKE_%28hash_function%29">BLAKE</a></b> hash function (one of SHA-3 finalists).<br>This is one of the fastest hash functions and we recommend it you are free to choose.</td><td>224 / 256 / 384 / 512</td>
</tr>
<tr>
<td><code>blake2b</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/BLAKE_%28hash_function%29#BLAKE2">BLAKE2b</a></b> hash function with variable output size up to 512 bits.<br>This is a version of BLAKE-512 with reduced number of rounds and other simplifications.</td><td>8 - 512</td>
</tr>
<tr>
<td><code>blake2s</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/BLAKE_%28hash_function%29#BLAKE2">BLAKE2s</a></b> hash function with variable output size up to 256 bits.<br>This is a version of BLAKE-256 with reduced number of rounds and other simplifications.</td><td>8 - 256</td>
</tr>
<tr>
<td><code>groestl</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Gr%C3%B8stl">Gr√∏stl</a></b> hash function (one of SHA-3 finalists).</td><td>8 - 512</td>
</tr>
<tr>
<td><code>jh</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/JH_%28hash_function%29">JH</a></b> hash function (one of SHA-3 finalists).</td><td>224 / 256 / 384 / 512</td>
</tr>
<tr>
<td><code>kupyna</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Kupyna">Kupyna</a></b> hash function (Ukrainian national standard DSTU 7564:2014) with output sizes 256/512 bits.<br>224/384-bit functions are not provided because their output is identical to the truncated 256/512-bit output.</td><td>256 / 512</td>
</tr>
<tr>
<td><code>md5</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/MD5">MD5</a></b> hash function. Not secure and therefore not recommended; use only if you need it for compatibility.</td><td>128</td>
</tr>
<tr>
<td><code>sha1</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a></b> hash function. Not secure and therefore not recommended; use only if you need it for compatibility.</td><td>160</td>
</tr>
<tr>
<td><code>sha224</code><br><code>sha256</code><br><code>sha384</code><br><code>sha512</code><br></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/SHA-2">SHA-2</a></b> hash function (NIST standard FIPS 180-4).
<br>Individual functions are known as SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 and SHA-512/256.
<br>SHA-512 supports variable output size up to 512 bits (SHA-512/t).
<br><code>sha512(224)</code> and <code>sha512(256)</code> are faster than <code>sha224</code> and <code>sha256</code> on 64-bit platforms.
</td><td>224 / 256 / 384 / 512,<br>8 - 512 (SHA-512/t)</td>
<!--<td class="descr"><b>SHA-2</b> hash function (NIST standard FIPS 180-4).<br>New functions <code>sha512_224</code> and <code>sha512_256</code> from the latest revision of the standard are faster than <code>sha224</code> and <code>sha256</code> on 64-bit platforms.</td>-->
</tr>
<tr>
<td><code>sha3</code><br><code>shake128</code><br><code>shake256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/SHA-3">SHA-3</a></b> hash function (NIST standard FIPS 202) based on Keccak algorithm.
<br>SHAKE-128 and SHAKE-256 support variable output size.
<br>cSHAKE-128 and cSHAKE-256 as defined by NIST SP 800-185 are also supported.
</td><td>224 / 256 / 384 / 512 (SHA-3)<br>arbitrary (SHAKE)</td>
</tr>
<tr>
<td><code>skein256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Skein_%28hash_function%29">Skein</a></b> hash function (one of SHA-3 finalists) with block size 256 bits and variable output size.<br>This algorithm is slower than <code>skein512</code> on modern PCs, so use it only if you need them for compatibility.</td><td>arbitrary</td>
</tr>
<tr>
<td><code>skein512</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Skein_%28hash_function%29">Skein</a></b> hash function (one of SHA-3 finalists) with block size 512 bits and variable output size.<br>This is one of the fastest hash functions and we recommend it if you are free to choose.</td><td>arbitrary</td>
</tr>
<tr>
<td><code>skein1024</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Skein_%28hash_function%29">Skein</a></b> hash function (one of SHA-3 finalists) with block size 1024 bits and variable output size.</td><td>arbitrary</td>
</tr>
<tr>
<td><code>sm3</code></td>
<td class="descr"><b>SM3</b> hash function (Chinese national standard)</td><td>256</td>
</tr>
<tr>
<td><code>streebog</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Streebog">Streebog</a></b> hash function (Russian standard GOST R 34.11-2012)</td><td>256 / 512</td>
</tr>
<tr>
<td><code>whirlpool</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Whirlpool_%28cryptography%29">Whirlpool</a></b> hash function (recommended by NESSIE)</td><td>512</td>
</tr>
</table>
<h3>2.3. Usage example</h3>
<p>The following snippet calculates BLAKE-256 hash of a string using a single function call:</p>
<pre>
    unsigned char hash[256/8];
    blake(256).hash_string("The quick brown fox jumps over the lazy dog", hash);
    // Now <i>hash</i> contains the hash
</pre>
<p>The following snippet demonstrates how to calculate the hash of a very long message using the init/update/final interface:</p>
<p></p>
<pre>
    blake(256) hasher;
    unsigned char hash[256/8];
    
    hasher.init();
    hasher.update(datachunk1, chunk1len);
    hasher.update(datachunk2, chunk2len);
    ...
    hasher.final(hash); // Now <i>hash</i> contains the hash
</pre>
<h3>2.4. Hashing performance</h3>
<p>Performance of various hash algorithms on three different test systems is provided in the table below (in megabytes per second).
<br>Note how 64-bit builds outperform 32-bit builds. For some algorithms 64-bit build is up to 5 times faster than 32-bit build on the same PC.
<br>It's also an interesting comparison between gcc 5.2.1 and clang 3.7.0 optimizers. Some algorithms are faster when compiled by clang, while others are faster when compiled by gcc.
</p>
<table>
<tr><th colspan="11" class="thh left top right bottom">Performance in megabytes per second (MB/s), higher number means faster<br><i>(measured by calculating a hash of a 130Kb file 100,000 times)</i></th></tr>
<tr>
<th class="left right" rowspan="2">Algorithm</th><th colspan="6" class="right">PC: Intel Xeon E5-1650 v3<br>(Haswell-EP)</th><th colspan="2" class="right">PC: Intel Core i7 930<br>(Nehalem)</th><th colspan="2" class="right">PC: Intel Core i3-3217U<br>(Ivy Bridge w/o AESNI)</th>
</tr>
<tr>
<th colspan="2" class="right">OS: Win7 x64<br>Compiler: VC++2015</th><th colspan="2" class="right">OS: openSUSE (in VM)<br>Compiler: gcc 5.2.1</th><th colspan="2" class="right">OS: openSUSE (in VM)<br>Compiler: clang 3.7.0</th><th colspan="2" class="right">OS: Win7 x64<br>Compiler: VC++2015</th><th colspan="2" class="right">OS: Win7 x64<br>Compiler: VC++2015</th>
</tr>
<tr>
</tr>
<tr><th class="thsa">128-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm">BLAKE2b/128</td><td>661</td><td class="right">543</td><td>651</td><td class="right">552</td><td>704</td><td class="right">605</td><td>490</td><td class="right">335</td><td>326</td><td class="right">262</td></tr>
<tr><td class="algorithm">BLAKE2s/128</td><td>554</td><td class="right">539</td><td>549</td><td class="right">542</td><td>554</td><td class="right">547</td><td>360</td><td class="right">205</td><td>274</td><td class="right">271</td></tr>
<tr><td class="algorithm">MD5</td><td>528</td><td class="right">509</td><td>634</td><td class="right">627</td><td>472</td><td class="right">472</td><td>382</td><td class="right">352</td><td>262</td><td class="right">252</td></tr>
<tr><td class="algorithm">Skein-256/128</td><td>383</td><td class="right">210</td><td>400</td><td class="right">186</td><td>396</td><td class="right">125</td><td>261</td><td class="right">164</td><td>175</td><td class="right">103</td></tr>
<tr><td class="algorithm">Skein-512/128</td><td>517</td><td class="right">234</td><td>570</td><td class="right">253</td><td>585</td><td class="right">118</td><td>340</td><td class="right">181</td><td>231</td><td class="right">112</td></tr>
<tr><th class="thsa">160-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm">BLAKE2b/160</td><td>661</td><td class="right">543</td><td>651</td><td class="right">552</td><td>704</td><td class="right">605</td><td>490</td><td class="right">335</td><td>326</td><td class="right">262</td></tr>
<tr><td class="algorithm">BLAKE2s/160</td><td>554</td><td class="right">539</td><td>549</td><td class="right">542</td><td>554</td><td class="right">547</td><td>360</td><td class="right">205</td><td>274</td><td class="right">271</td></tr>
<tr><td class="algorithm">Skein-256/160</td><td>383</td><td class="right">210</td><td>400</td><td class="right">186</td><td>396</td><td class="right">125</td><td>261</td><td class="right">164</td><td>175</td><td class="right">103</td></tr>
<tr><td class="algorithm">Skein-512/160</td><td>517</td><td class="right">234</td><td>570</td><td class="right">253</td><td>585</td><td class="right">118</td><td>340</td><td class="right">181</td><td>231</td><td class="right">112</td></tr>
<tr><td class="algorithm">SHA-1</td><td>789</td><td class="right">522</td><td>784</td><td class="right">512</td><td>784</td><td class="right">508</td><td>480</td><td class="right">392</td><td>361</td><td class="right">247</td></tr>
<tr><th class="thsa">224-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm">BLAKE-224</td><td>423</td><td class="best right">417</td><td>421</td><td class="right">392</td><td>427</td><td class="right">404</td><td>271</td><td class="right">151</td><td>208</td><td class="best right">204</td></tr>
<tr><td class="algorithm">BLAKE2b/224</td><td>661</td><td class="right">543</td><td>651</td><td class="right">552</td><td>704</td><td class="right">605</td><td>490</td><td class="right">335</td><td>326</td><td class="right">262</td></tr>
<tr><td class="algorithm">BLAKE2s/224</td><td>554</td><td class="right">539</td><td>549</td><td class="right">542</td><td>554</td><td class="right">547</td><td>360</td><td class="right">205</td><td>274</td><td class="right">271</td></tr>
<tr><td class="algorithm">Groestl-224</td><td>326</td><td class="right">270</td><td>279</td><td class="right">227</td><td>322</td><td class="right">229</td><td>112</td><td class="right">99</td><td>73</td><td class="right">71</td></tr>
<tr><td class="algorithm">JH-224</td><td>206</td><td class="right">146</td><td>198</td><td class="right">156</td><td>205</td><td class="right">138</td><td>132</td><td class="right">91</td><td>95</td><td class="right">71</td></tr>
<tr><td class="algorithm">SHA-224</td><td>398</td><td class="right">293</td><td>382</td><td class="right">282</td><td>382</td><td class="right">282</td><td>202</td><td class="right">162</td><td>149</td><td class="right">127</td></tr>
<tr><td class="algorithm">SHA-512/224</td><td class="best">552</td><td class="right">211</td><td>534</td><td class="right">203</td><td>532</td><td class="right">203</td><td>298</td><td class="right">155</td><td>214</td><td class="right">97</td></tr>
<tr><td class="algorithm">SHA3-224</td><td>358</td><td class="right">322</td><td>358</td><td class="right">301</td><td>360</td><td class="right">293</td><td>174</td><td class="right">143</td><td>122</td><td class="right">109</td></tr>
<tr><td class="algorithm">Skein-256/224</td><td>383</td><td class="right">210</td><td>400</td><td class="right">186</td><td>396</td><td class="right">125</td><td>261</td><td class="right">164</td><td>175</td><td class="right">103</td></tr>
<tr><td class="algorithm">Skein-512/224</td><td>517</td><td class="right">234</td><td>570</td><td class="right">253</td><td>585</td><td class="right">118</td><td class="best">340</td><td class="best right">181</td><td class="best">231</td><td class="right">112</td></tr>

<tr><th class="thsa">256-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm">BLAKE-256</td><td>423</td><td class="best right">417</td><td>421</td><td class="right">392</td><td>427</td><td class="right">404</td><td>271</td><td class="right">151</td><td>208</td><td class="best right">204</td></tr>
<tr><td class="algorithm">BLAKE2b/256</td><td>661</td><td class="right">543</td><td>651</td><td class="right">552</td><td>704</td><td class="right">605</td><td>490</td><td class="right">335</td><td>326</td><td class="right">262</td></tr>
<tr><td class="algorithm">BLAKE2s/256</td><td>554</td><td class="right">539</td><td>549</td><td class="right">542</td><td>554</td><td class="right">547</td><td>360</td><td class="right">205</td><td>274</td><td class="right">271</td></tr>
<tr><td class="algorithm">Groestl-256</td><td>326</td><td class="right">270</td><td>279</td><td class="right">227</td><td>322</td><td class="right">229</td><td>112</td><td class="right">99</td><td>73</td><td class="right">71</td></tr>
<tr><td class="algorithm">JH-256</td><td>206</td><td class="right">146</td><td>198</td><td class="right">156</td><td>205</td><td class="right">138</td><td>132</td><td class="right">91</td><td>95</td><td class="right">71</td></tr>
<tr><td class="algorithm">Kupyna-256</td><td>127</td><td class="right">54</td><td>111</td><td class="right">54</td><td>113</td><td class="right">79</td><td>77</td><td class="right">28</td><td>53</td><td class="right">25</td></tr>
<tr><td class="algorithm">SHA-256</td><td>398</td><td class="right">293</td><td>382</td><td class="right">282</td><td>382</td><td class="right">282</td><td>202</td><td class="right">162</td><td>149</td><td class="right">127</td></tr>
<tr><td class="algorithm">SHA-512/256</td><td class="best">552</td><td class="right">211</td><td>534</td><td class="right">203</td><td>532</td><td class="right">203</td><td>298</td><td class="right">155</td><td>214</td><td class="right">97</td></tr>
<tr><td class="algorithm">SHA3-256</td><td>338</td><td class="right">304</td><td>340</td><td class="right">275</td><td>339</td><td class="right">276</td><td>164</td><td class="right">133</td><td>114</td><td class="right">103</td></tr>
<tr><td class="algorithm">Skein-256/256</td><td>383</td><td class="right">210</td><td>400</td><td class="right">186</td><td>396</td><td class="right">125</td><td>261</td><td class="right">164</td><td>175</td><td class="right">103</td></tr>
<tr><td class="algorithm">Skein-512/256</td><td>517</td><td class="right">234</td><td>570</td><td class="right">253</td><td>585</td><td class="right">118</td><td class="best">340</td><td class="best right">181</td><td class="best">231</td><td class="right">112</td></tr>
<tr><td class="algorithm">Skein-1024/256</td><td>406</td><td class="right">106</td><td>481</td><td class="right">93</td><td>479</td><td class="right">108</td><td>217</td><td class="right">63</td><td>144</td><td class="right">38</td></tr>
<tr><td class="algorithm">SM3</td><td>186</td><td class="right">140</td><td>166</td><td class="right">143</td><td>170</td><td class="right">148</td><td>117</td><td class="right">101</td><td>81</td><td class="right">70</td></tr>
<tr><td class="algorithm">Streebog-256</td><td>112</td><td class="right">64</td><td>116</td><td class="right">64</td><td>113</td><td class="right">68</td><td>69</td><td class="right">42</td><td>50</td><td class="right">32</td></tr>

<tr><th class="thsa">384-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>

<tr><td class="algorithm">BLAKE-384</td><td>471</td><td class="best right">411</td><td>477</td><td class="right">421</td><td>540</td><td class="right">437</td><td class="best">340</td><td class="best right">217</td><td>227</td><td class="best right">202</td></tr>
<tr><td class="algorithm">BLAKE2b/384</td><td>661</td><td class="right">543</td><td>651</td><td class="right">552</td><td>704</td><td class="right">605</td><td>490</td><td class="right">335</td><td>326</td><td class="right">262</td></tr>
<tr><td class="algorithm">Groestl-384</td><td>246</td><td class="right">197</td><td>220</td><td class="right">181</td><td>234</td><td class="right">182</td><td>83</td><td class="right">73</td><td>54</td><td class="right">52</td></tr>
<tr><td class="algorithm">JH-384</td><td>206</td><td class="right">146</td><td>198</td><td class="right">156</td><td>205</td><td class="right">138</td><td>132</td><td class="right">91</td><td>95</td><td class="right">71</td></tr>
<tr><td class="algorithm">SHA-384</td><td class="best">552</td><td class="right">211</td><td>534</td><td class="right">203</td><td>532</td><td class="right">203</td><td>298</td><td class="right">155</td><td>214</td><td class="right">97</td></tr>
<tr><td class="algorithm">SHA3-384</td><td>260</td><td class="right">233</td><td>260</td><td class="right">203</td><td>258</td><td class="right">211</td><td>126</td><td class="right">103</td><td>89</td><td class="right">79</td></tr>
<tr><td class="algorithm">Skein-512/384</td><td>517</td><td class="right">234</td><td>570</td><td class="right">253</td><td>585</td><td class="right">118</td><td class="best">340</td><td class="right">181</td><td class="best">231</td><td class="right">112</td></tr>
<tr><td class="algorithm">Skein-1024/384</td><td>406</td><td class="right">106</td><td>481</td><td class="right">93</td><td>479</td><td class="right">108</td><td>217</td><td class="right">63</td><td>144</td><td class="right">38</td></tr>

<tr><th class="thsa">512-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm">BLAKE-512</td><td>471</td><td class="best right">411</td><td>477</td><td class="right">421</td><td>540</td><td class="right">437</td><td class="best">340</td><td class="best right">217</td><td>227</td><td class="best right">202</td></tr>
<tr><td class="algorithm">BLAKE2b/512</td><td>661</td><td class="right">543</td><td>651</td><td class="right">552</td><td>704</td><td class="right">605</td><td>490</td><td class="right">335</td><td>326</td><td class="right">262</td></tr>
<tr><td class="algorithm">Groestl-512</td><td>246</td><td class="right">197</td><td>220</td><td class="right">181</td><td>234</td><td class="right">182</td><td>83</td><td class="right">73</td><td>54</td><td class="right">52</td></tr>
<tr><td class="algorithm">JH-512</td><td>206</td><td class="right">146</td><td>198</td><td class="right">156</td><td>205</td><td class="right">138</td><td>132</td><td class="right">91</td><td>95</td><td class="right">71</td></tr>
<tr><td class="algorithm">Kupyna-512</td><td>81</td><td class="right">43</td><td>84</td><td class="right">41</td><td>88</td><td class="right">59</td><td>49</td><td class="right">22</td><td>23</td><td class="right">20</td></tr>
<tr><td class="algorithm">SHA-512</td><td class="best">552</td><td class="right">211</td><td>534</td><td class="right">203</td><td>532</td><td class="right">203</td><td>298</td><td class="right">155</td><td>214</td><td class="right">97</td></tr>
<tr><td class="algorithm">SHA3-512</td><td>180</td><td class="right">162</td><td>180</td><td class="right">148</td><td>181</td><td class="right">147</td><td>81</td><td class="right">72</td><td>61</td><td class="right">49</td></tr>
<tr><td class="algorithm">Skein-512/512</td><td>517</td><td class="right">234</td><td>570</td><td class="right">253</td><td>585</td><td class="right">118</td><td class="best">340</td><td class="right">181</td><td class="best">231</td><td class="right">112</td></tr>
<tr><td class="algorithm">Skein-1024/512</td><td>406</td><td class="right">106</td><td>481</td><td class="right">93</td><td>479</td><td class="right">108</td><td>217</td><td class="right">63</td><td>144</td><td class="right">38</td></tr>
<tr><td class="algorithm">Streebog-512</td><td>112</td><td class="right">64</td><td>116</td><td class="right">64</td><td>113</td><td class="right">68</td><td>69</td><td class="right">42</td><td>50</td><td class="right">32</td></tr>
<tr><td class="algorithm">Whirlpool</td><td>150</td><td class="right">125</td><td>147</td><td class="right">122</td><td>162</td><td class="right">122</td><td>80</td><td class="right">89</td><td>61</td><td class="right">58</td></tr>

<tr><th class="thsa">1024-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm bottom">Skein-1024/1024</td><td class="bottom">406</td><td class="bottom right">106</td><td class="bottom">481</td><td class="right bottom">93</td><td class="bottom">479</td><td class="right bottom">108</td><td class="bottom">217</td><td class="bottom right">63</td><td class="bottom">144</td><td class="bottom right">38</td></tr>

</table>
<p>You can run the hashing performance test on your own PC using the following command:</p>
<pre>    digest test &lt;number_of_iterations&gt; &lt;filename_to_hash&gt;</pre>
<h2 id="chmac">3. MAC algorithms</h2>
<h3>3.1 HMAC</h3>
<p>Class <code>hmac</code> is also derived from <code>crypto_hash</code> and implements the same interface. The only difference is that you need to pass a reference to a hash algorithm and a key in the constructor.
<pre>
    hmac(const crypto_hash& hash, const unsigned char* key, size_t keylen);
</pre>
<p>The key can be of any length and you can use any of the supported hash algorithms to calculate HMAC. The following sample calculates HMAC-SHA-256 of a string &quot;The quick brown fox jumps over the lazy dog&quot; with key &quot;key&quot;:</p>
<pre>
    unsigned char hmackey[3];
    hmackey[0] = 'k';
    hmackey[1] = 'e';
    hmackey[2] = 'y';
    hmac mac(sha256(), hmackey, sizeof(hmackey));
    unsigned char result[32];
    mac.hash_string("The quick brown fox jumps over the lazy dog", result);
</pre>
<h3>3.2 Poly1305</h3>
<p>Class <code>poly1305</code> is also derived from <code>crypto_hash</code> and implements the same interface. The only difference is that you need to pass a key in the constructor.
<pre>
    poly1305(const unsigned char* key, size_t keylen);
</pre>
<p>The key <b><i>must</i></b> have length 32 bytes (256 bits). The following sample calculates Poly1305 of a string &quot;The quick brown fox jumps over the lazy dog&quot; with key &quot;\x00\x01\x02...\x31&quot;:</p>
<pre>
    unsigned char key[32];
    std::iota(key, key + 32, 0);
    poly1305 poly(key, sizeof(key));
    unsigned char result[16];
    poly.hash_string("The quick brown fox jumps over the lazy dog", result);
</pre>
<h2 id="chbc">4. Block cipher algorithms</h2>
<h3>4.1. Interface description</h3>
<p>All block cipher algorithms derive from <code>block_cipher</code> class and implement its interface.</p>
<pre>
    class block_cipher
    {
    public:
        enum direction { encryption, decryption };

        virtual size_t blocksize() const = 0;
        virtual size_t keysize() const = 0;

        virtual bool init(const unsigned char* key, block_cipher::direction direction) = 0;
        virtual void encrypt_block(const unsigned char* in, unsigned char* out) = 0;
        virtual void decrypt_block(const unsigned char* in, unsigned char* out) = 0;
    };
</pre>
<p>A low-level interface to the block cipher. To start encryption or decryption, call <code>init()</code> (<code>key</code> should point to a key of <code>keysize()/8</code> bytes), then call <code>encrypt_block()</code> or <code>decrypt_block()</code> to encrypt or decrypt a single block of <code>blocksize()/8</code> bytes.<br>
In practice in most cases you probably want to use block ciphers in an encryption mode via <code>cbc</code> or <code>ctr</code> class described below.</p>
</html>
<h3>4.2. Supported algorithms</h3>
<p>Classes derived from <code>block_cipher</code>:</p>
<table>
<tr><th>Class Name</th><th>Description</th><th>Supported block sizes</th><th>Supported key sizes</th></tr>
<tr>
<td><code>anubis128</code><br><code>anubis160</code><br><code>anubis192</code><br><code>anubis224</code><br><code>anubis256</code><br><code>anubis288</code><br><code>anubis320</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Anubis_%28cipher%29">Anubis</a></b> cipher</td><td>128</td><td>128 / 160 / 192 / 224 / 256 / 288 / 320</td>
</tr>
<tr>
<td><code>aria128</code><br><code>aria192</code><br><code>aria256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/ARIA_%28cipher%29">Aria</a></b> cipher (South Korean national standard)</td><td>128</td><td>128 / 192 / 256</td>
</tr>
<tr>
<td><code>cast6_128</code><br><code>cast6_160</code><br><code>cast6_192</code><br><code>cast6_224</code><br><code>cast6_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/CAST-256">CAST6</a></b> (aka <b>CAST-256</b>) cipher</td><td>128</td><td>128 / 160 / 192 / 224 / 256</td>
</tr>
<tr>
<td><code>camellia128</code><br><code>camellia192</code><br><code>camellia256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Camellia_%28cipher%29">Camellia</a></b> cipher (recommended by NESSIE and CRYPTREC)</td><td>128</td><td>128 / 192 / 256</td>
</tr>
<tr>
<td><code>kalyna128_128</code><br><code>kalyna128_256</code><br><code>kalyna256_256</code><br><code>kalyna256_512</code><br><code>kalyna512_512</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Kalyna_(cipher)">Kalyna</a></b> cipher (Ukrainian national standard DSTU 7624:2014)</td><td>128 / 256 / 512</td><td>128 / 256 / 512</td>
</tr>
<tr>
<td><code>kuznyechik</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Kuznyechik">Kuznyechik</a></b> cipher (Russian national standard GOST R 34.12-2015)</td><td>128</td><td>256</td>
</tr>
<tr>
<td><code>mars128</code><br><code>mars160</code><br><code>mars192</code><br><code>mars224</code><br><code>mars256</code><br><code>mars288</code><br><code>mars320</code><br><code>mars352</code><br><code>mars384</code><br><code>mars416</code><br><code>mars448</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/MARS_%28cryptography%29">MARS</a></b> cipher (one of AES finalists)</td><td>128</td><td>128 / 160 / 192 / 224 / 256 / 288 / 320 / 352 / 384 / 416 / 448</td>
</tr>
<tr>
<td><code>rijndael128_128</code><br><code>rijndael128_160</code><br><code>rijndael128_192</code><br><code>rijndael128_224</code><br><code>rijndael128_256</code>
<br><code>rijndael160_128</code><br><code>rijndael160_160</code><br><code>rijndael160_192</code><br><code>rijndael160_224</code><br><code>rijndael160_256</code>
<br><code>rijndael192_128</code><br><code>rijndael192_160</code><br><code>rijndael192_192</code><br><code>rijndael192_224</code><br><code>rijndael192_256</code>
<br><code>rijndael224_128</code><br><code>rijndael224_160</code><br><code>rijndael224_192</code><br><code>rijndael224_224</code><br><code>rijndael224_256</code>
<br><code>rijndael256_128</code><br><code>rijndael256_160</code><br><code>rijndael256_192</code><br><code>rijndael256_224</code><br><code>rijndael256_256</code>
</td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael</a></b> cipher (AES winner)<br><br>Rijndael with block size 128 bits and key size 128, 192, 256 bits<br>is also known as<br> <b>AES-128, AES-192, AES-256</b>.<br><br>All 25 Rijndael variants are accelerated using AES-NI instructions,<br>if they are supported by CPU.</td><td>128 / 160 / 192 / 224 / 256</td><td>128 / 160 / 192 / 224 / 256</td>
</tr>
<tr>
<td><code>serpent128</code><br><code>serpent192</code><br><code>serpent256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Serpent_%28cipher%29">Serpent</a></b> cipher (one of AES finalists)</td><td>128</td><td>128 / 192 / 256</td>
</tr>
<tr>
<td><code>simon128_128</code><br><code>simon128_192</code><br><code>simon128_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Simon_%28cipher%29">Simon</a></b> cipher</td><td>128</td><td>128 / 192 / 256</td>
</tr>
<tr>
<td><code>sm4</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/SMS4">SM4</a></b> cipher (Chinese national standard for Wireless LAN)</td><td>128</td><td>128</td>
</tr>
<tr>
<td><code>speck128_128</code><br><code>speck128_192</code><br><code>speck128_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Speck_%28cipher%29">Speck</a></b> cipher</td><td>128</td><td>128 / 192 / 256</td>
</tr>
<tr>
<td><code>threefish256_256</code><br><code>threefish512_512</code><br><code>threefish1024_1024</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Threefish">Threefish</a></b> cipher</td><td>256 / 512 / 1024</td><td>256 / 512 / 1024</td>
</tr>
<tr>
<td><code>twofish128</code><br><code>twofish192</code><br><code>twofish256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Twofish">Twofish</a></b> cipher (one of AES finalists)</td><td>128</td><td>128 / 192 / 256</td>
</tr>
</table>
<h2 id="chem">5. Block cipher encryption modes</h2>
<h3>5.1. CBC mode</h3>
<p>Class <code>cbc</code> implements the following interface:</p>
<pre>
    cbc(const block_cipher& cipher);

    void init(const unsigned char* key, size_t keylen, const unsigned char* iv, size_t ivlen, block_cipher::direction direction);

    <i>// Functions writing output to preallocated raw buffer (the fastest)</i>
    void encrypt_update(const unsigned char* in, size_t len, unsigned char* out, size_t& resultlen);
    void encrypt_final(unsigned char* out, size_t& resultlen);
    void decrypt_update(const unsigned char* in, size_t len, unsigned char* out, size_t& resultlen);
    void decrypt_final(unsigned char* out, size_t& resultlen);

    <i>// Functions writing output to std::vector (slower)</i>
    void encrypt_update(const unsigned char* in, size_t len, std::vector&lt;unsigned char&gt;& out);
    void encrypt_final(std::vector<unsigned char>& out);
    void decrypt_update(const unsigned char* in, size_t len, std::vector&lt;unsigned char&gt;& out);
    void decrypt_final(std::vector<unsigned char>& out);

    <i>// Functions writing output to std::ostream (the slowest)</i>
    void encrypt_update(const unsigned char* in, size_t len, std::ostream& out);
    void encrypt_final(std::ostream& out);
    void decrypt_update(const unsigned char* in, size_t len, std::ostream& out);
    void decrypt_final(std::ostream& out);
</pre>
<p>The functions are similar to the ones from the <code>crypto_hash</code> class.</p><p>To start encryption, pass one of the block ciphers to the constructor and initialize encryption using <code>init()</code> function. The length of the key in bytes should be equal to <code>keysize()/8</code> of the block cipher, and the length of the initialization vector (<code>iv</code>) in bytes should be equal to <code>blocksize()/8</code> of the block cipher. Then call <code>encrypt_update()</code> any number of times to add the next chunk of data of variable length. When all input is consumed by <code>encrypt_update()</code> function, call <code>encrypt_final()</code> to finish the encryption (at this stage the final block will be written to <code>out</code>).
<p>Decryption is done in a similar way.</p>
<p>If you use the low-level functions that write the output to a preallocated buffer, the <code>out</code> argument should point to the next location where the encrypted output should be written; <code>resultlen</code> is the number of bytes written to <code>out</code> as the result of the function call. Because the class implements PKCS#7 padding, the overall size of the output buffer should be equal to the size of the input rounded up to the block size of the cipher algorithm, plus one additional full block if the input size is the exact multiple of the block size. It is responsibility of the caller to make sure the buffer is large enough.</p>
<p>A simpler but slower interface accepts a reference to <code>std::vector&lt;unsigned char&gt;</code> and appends encryption or decryption result to this vector, which is dynamically resized as needed, so that you do not need to calculate and allocate a buffer of proper size in advance.</p>
<p>An even simpler but slower interface writes the output to <code>std::ostream</code>.</p>
<p>Note that regardless of which interface you use, you still need to call <code>init()</code> function to set up the key and initialization vector.</p>
<h3>5.2. CTR mode</h3>
<p>Class <code>ctr</code> implements the <code>stream_cipher</code> interface for block ciphers:</p>
<pre>
    ctr(const block_cipher& cipher);

    void init(const unsigned char* key, size_t keylen, const unsigned char* iv, size_t ivlen);
    void encrypt(const unsigned char* in, size_t len, unsigned char* out);
    void decrypt(const unsigned char* in, size_t len, unsigned char* out);
</pre>
<p>CTR mode turns block cipher into a stream cipher, so no padding is needed in this mode and the size of the output buffer must be the same as the size of the input data.
The length of the key in bytes should be equal to <code>keysize()/8</code> of the block cipher, and the length of the initialization vector (<code>iv</code>) in bytes should be equal to or smaller than <code>blocksize()/8</code> of the block cipher.
Since all output is produced immediately, no finalization function is needed in this mode.</p>
<h3>5.3. Encryption performance</h3>
<table>
<tr><th colspan="7" class="thh left top right">
Performance in megabytes per second (MB/s), higher number means faster<br><i>(measured by encrypting a 130Kb file in CBC mode 100,000 times)</i>
</th></tr>
<tr>
<th rowspan="3" class="left right top bottom">Algorithm</th><th colspan="6" class="left right top">PC: Intel Xeon E5-1650 v3</th>
</tr>
<tr>
<th colspan="2" class="left right">OS: Win7 x64<br>Compiler: VC++2015</th>
<th colspan="2" class="left right">OS: openSUSE (in VM)<br>Compiler: gcc 5.2.1</th>
<th colspan="2" class="left right">OS: openSUSE (in VM)<br>Compiler: clang 3.7.0</th>
</tr>
<tr>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm">Anubis-128</td><td class="top">225</td><td class="right top">138</td><td class="top">208</td><td class="right top">178</td><td class="top">198</td><td class="right top">169</td>
<tr><td class="algorithm">Anubis-160</td><td>206</td><td class="right">128</td><td>195</td><td class="right">167</td><td>186</td><td class="right">156</td>
<tr><td class="algorithm">Anubis-192</td><td>198</td><td class="right">119</td><td>196</td><td class="right">157</td><td>172</td><td class="right">145</td>
<tr><td class="algorithm">Anubis-224</td><td>186</td><td class="right">112</td><td>186</td><td class="right">147</td><td>162</td><td class="right">137</td>
<tr><td class="algorithm">Anubis-256</td><td>176</td><td class="right">105</td><td>175</td><td class="right">138</td><td>152</td><td class="right">128</td>
<tr><td class="algorithm">Anubis-288</td><td>163</td><td class="right">100</td><td>166</td><td class="right">130</td><td>146</td><td class="right">121</td>
<tr><td class="algorithm">Anubis-320</td><td>157</td><td class="right">94</td><td>158</td><td class="right">124</td><td>136</td><td class="right">115</td>
<tr><td class="algorithm top">Aria-128</td><td class="top">135</td><td class="right top">113</td><td class="top">155</td><td class="right top">154</td><td class="top">150</td><td class="right top">153</td>
<tr><td class="algorithm">Aria-192</td><td>116</td><td class="right">98</td><td>134</td><td class="right">133</td><td>129</td><td class="right">133</td>
<tr><td class="algorithm">Aria-256</td><td>102</td><td class="right">86</td><td>119</td><td class="right">118</td><td>114</td><td class="right">117</td>
<tr><td class="algorithm top">Camellia-128</td><td class="top">148</td><td class="right top">94</td><td class="top">153</td><td class="right top">130</td><td class="top">143</td><td class="right top">149</td>
<tr><td class="algorithm">Camellia-192</td><td>113</td><td class="right">71</td><td>118</td><td class="right">99</td><td>108</td><td class="right">114</td>
<tr><td class="algorithm">Camellia-256</td><td>113</td><td class="right">71</td><td>117</td><td class="right">99</td><td>108</td><td class="right">114</td>
<tr><td class="algorithm top">CAST6-128</td><td class="top">109</td><td class="right top">99</td><td class="top">104</td><td class="right top">101</td><td class="top">102</td><td class="right top">94</td>
<tr><td class="algorithm">CAST6-160</td><td>109</td><td class="right">99</td><td>104</td><td class="right">101</td><td>102</td><td class="right">94</td>
<tr><td class="algorithm">CAST6-192</td><td>109</td><td class="right">99</td><td>104</td><td class="right">101</td><td>102</td><td class="right">94</td>
<tr><td class="algorithm">CAST6-224</td><td>109</td><td class="right">99</td><td>104</td><td class="right">101</td><td>102</td><td class="right">94</td>
<tr><td class="algorithm bottom">CAST6-256</td><td class="bottom">109</td><td class="right bottom">99</td><td>104</td><td class="right">101</td><td>102</td><td class="right">94</td>
<tr><td class="algorithm top">Kalyna-128/128</td><td class="top">179</td><td class="right top">112</td><td class="top">236</td><td class="right top">130</td><td class="top">206</td><td class="right top">186</td>
<tr><td class="algorithm">Kalyna-128/256</td><td>132</td><td class="right">82</td><td>175</td><td class="right">95</td><td>148</td><td class="right">137</td>
<tr><td class="algorithm">Kalyna-256/256</td><td>177</td><td class="right">85</td><td>206</td><td class="right">88</td><td>167</td><td class="right">113</td>
<tr><td class="algorithm">Kalyna-256/512</td><td>140</td><td class="right">67</td><td>135</td><td class="right">69</td><td>131</td><td class="right">89</td>
<tr><td class="algorithm">Kalyna-512/512</td><td>155</td><td class="right">66</td><td>124</td><td class="right">71</td><td>119</td><td class="right">83</td>
<tr><td class="algorithm top">Kuznyechik</td><td class="top">109</td><td class="right top">60</td><td class="top">113</td><td class="right top">68</td><td class="top">112</td><td class="right top">70</td>
<tr><td class="algorithm top">Mars-128</td><td class="top">159</td><td class="right top">136</td><td class="top">154</td><td class="right top">154</td><td class="top">138</td><td class="right top">140</td>
<tr><td class="algorithm">Mars-160</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-192</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-224</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-256</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-288</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-320</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-352</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-384</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-416</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-448</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm top">Rijndael-128/128</td><td class="top">657</td><td class="right top">656</td><td class="top">633</td><td class="right top">632</td><td class="top">633</td><td class="right top">629</td>
<tr><td class="algorithm">Rijndael-128/160</td><td>607</td><td class="right">607</td><td>589</td><td class="right">578</td><td>588</td><td class="right">579</td>
<tr><td class="algorithm">Rijndael-128/192</td><td>564</td><td class="right">566</td><td>541</td><td class="right">544</td><td>545</td><td class="right">537</td>
<tr><td class="algorithm">Rijndael-128/224</td><td>525</td><td class="right">527</td><td>505</td><td class="right">506</td><td>505</td><td class="right">502</td>
<tr><td class="algorithm">Rijndael-128/256</td><td>493</td><td class="right">490</td><td>472</td><td class="right">474</td><td>476</td><td class="right">471</td>
<tr><td class="algorithm top">Rijndael-160/128</td><td class="top">339</td><td class="right top">253</td><td class="top">315</td><td class="right top">290</td><td class="top">331</td><td class="right top">322</td>
<tr><td class="algorithm">Rijndael-160/160</td><td>339</td><td class="right">254</td><td>315</td><td class="right">290</td><td>331</td><td class="right">322</td>
<tr><td class="algorithm">Rijndael-160/192</td><td>318</td><td class="right">238</td><td>293</td><td class="right">272</td><td>310</td><td class="right">302</td>
<tr><td class="algorithm">Rijndael-160/224</td><td>299</td><td class="right">223</td><td>276</td><td class="right">258</td><td>292</td><td class="right">286</td>
<tr><td class="algorithm">Rijndael-160/256</td><td>282</td><td class="right">211</td><td>263</td><td class="right">245</td><td>275</td><td class="right">267</td>
<tr><td class="algorithm top">Rijndael-192/128</td><td class="top">425</td><td class="right top">373</td><td class="top">361</td><td class="right top">327</td><td class="top">459</td><td class="right top">452</td>
<tr><td class="algorithm">Rijndael-192/160</td><td>425</td><td class="right">373</td><td>355</td><td class="right">330</td><td>456</td><td class="right">457</td>
<tr><td class="algorithm">Rijndael-192/192</td><td>425</td><td class="right">373</td><td>357</td><td class="right">327</td><td>457</td><td class="right">456</td>
<tr><td class="algorithm">Rijndael-192/224</td><td>399</td><td class="right">352</td><td>333</td><td class="right">309</td><td>429</td><td class="right">426</td>
<tr><td class="algorithm">Rijndael-192/256</td><td>378</td><td class="right">334</td><td>320</td><td class="right">295</td><td>402</td><td class="right">398</td>
<tr><td class="algorithm top">Rijndael-224/128</td><td class="top">370</td><td class="right top">287</td><td class="top">332</td><td class="right top">306</td><td class="top">355</td><td class="right top">346</td>
<tr><td class="algorithm">Rijndael-224/160</td><td>370</td><td class="right">287</td><td>332</td><td class="right">306</td><td>355</td><td class="right">346</td>
<tr><td class="algorithm">Rijndael-224/192</td><td>370</td><td class="right">287</td><td>332</td><td class="right">306</td><td>355</td><td class="right">346</td>
<tr><td class="algorithm">Rijndael-224/224</td><td>370</td><td class="right">287</td><td>334</td><td class="right">306</td><td>355</td><td class="right">346</td>
<tr><td class="algorithm">Rijndael-224/256</td><td>349</td><td class="right">268</td><td>314</td><td class="right">290</td><td>334</td><td class="right">329</td>
<tr><td class="algorithm top">Rijndael-256/128</td><td class="top">528</td><td class="right top">527</td><td class="top">501</td><td class="right top">501</td><td class="top">501</td><td class="right top">499</td>
<tr><td class="algorithm">Rijndael-256/160</td><td>528</td><td class="right">527</td><td>501</td><td class="right">501</td><td>501</td><td class="right">499</td>
<tr><td class="algorithm">Rijndael-256/192</td><td>528</td><td class="right">527</td><td>501</td><td class="right">501</td><td>501</td><td class="right">499</td>
<tr><td class="algorithm">Rijndael-256/224</td><td>528</td><td class="right">527</td><td>501</td><td class="right">501</td><td>501</td><td class="right">499</td>
<tr><td class="algorithm">Rijndael-256/256</td><td>528</td><td class="right">527</td><td>501</td><td class="right">501</td><td>501</td><td class="right">499</td>
<tr><td class="algorithm top">Serpent-128</td><td class="top">84</td><td class="right top">96</td><td class="top">89</td><td class="right top">93</td><td class="top">90</td><td class="right top">93</td>
<tr><td class="algorithm">Serpent-192</td><td>84</td><td class="right">96</td><td>89</td><td class="right">93</td><td>90</td><td class="right">93</td>
<tr><td class="algorithm bottom">Serpent-256</td><td class="bottom">84</td><td class="right bottom">96</td><td>89</td><td class="right">93</td><td>90</td><td class="right">93</td>
<tr><td class="algorithm top">Simon-128/128</td><td class="top">135</td><td class="right top">46</td><td class="top">136</td><td class="right top">43</td><td class="top">142</td><td class="right top">61</td>
<tr><td class="algorithm">Simon-128/192</td><td>128</td><td class="right">53</td><td>134</td><td class="right">43</td><td>155</td><td class="right">65</td>
<tr><td class="algorithm bottom">Simon-128/256</td><td class="bottom">128</td><td class="right bottom">44</td><td>130</td><td class="right">40</td><td>134</td><td class="right">58</td>
<tr><td class="algorithm top">SM4</td><td class="top">77</td><td class="right top">75</td><td class="top">91</td><td class="right top">95</td><td class="top">75</td><td class="right top">80</td>
<tr><td class="algorithm top">Speck-128/128</td><td class="top">423</td><td class="right top">199</td><td class="top">422</td><td class="right top">122</td><td class="top">427</td><td class="right top">206</td>
<tr><td class="algorithm">Speck-128/192</td><td>416</td><td class="right">201</td><td>411</td><td class="right">120</td><td>414</td><td class="right">200</td>
<tr><td class="algorithm bottom">Speck-128/256</td><td class="bottom">399</td><td class="right bottom">201</td><td>403</td><td class="right">115</td><td>406</td><td class="right">194</td>
<tr><td class="algorithm top">Threefish-256/256</td><td class="top">334</td><td class="right top">115</td><td class="top">408</td><td class="right top">111</td><td class="top">396</td><td class="right top">137</td>
<tr><td class="algorithm">Threefish-512/512</td><td>343</td><td class="right">118</td><td>620</td><td class="right">108</td><td>610</td><td class="right">129</td>
<tr><td class="algorithm">Threefish-1024/1024</td><td>324</td><td class="right">104</td><td>359</td><td class="right">83</td><td>361</td><td class="right">100</td>
<tr><td class="algorithm top">Twofish-128</td><td class="top">171</td><td class="right top">151</td><td class="top">171</td><td class="right top">164</td><td class="top">162</td><td class="right top">167</td>
<tr><td class="algorithm">Twofish-192</td><td>171</td><td class="right">151</td><td>171</td><td class="right">164</td><td>162</td><td class="right">167</td>
<tr><td class="algorithm bottom">Twofish-256</td><td class="bottom">171</td><td class="right bottom">151</td><td class="bottom">171</td><td class="right bottom">164</td><td class="bottom">162</td><td class="right bottom">167</td>
</table>
<p>You can run the block cipher encryption performance test on your own PC using the following command:</p>
<pre>    digest bctest &lt;number_of_iterations&gt; &lt;filename_to_encrypt&gt;</pre>
<h2 id="chsc">6. Stream cipher algorithms</h2>
<h3>6.1. Interface description</h3>
<p>All stream cipher algorithms derive from <code>stream_cipher</code> class and implement its interface.</p>
<pre>
    class stream_cipher
    {
    public:
        virtual size_t keysize() const = 0;
        virtual size_t ivsize() const = 0;

        virtual void init(const unsigned char* key, size_t keylen, const unsigned char* iv, size_t ivlen) = 0;
        virtual void encrypt(const unsigned char* in, size_t len, unsigned char* out) = 0;
        virtual void decrypt(const unsigned char* in, size_t len, unsigned char* out) = 0;
    };
</pre>
<p>To start encryption or decryption, call <code>init()</code> (<code>key</code> should point to a key of <code>keysize()/8</code> bytes, and iv should point to an initialization vector of <code>ivsize()/8</code> bytes). Then call <code>encrypt()</code> or <code>decrypt()</code> to encrypt or decrypt a stream of any length.</p>
</html>
<h3>6.2. Supported algorithms</h3>
<p>Classes derived from <code>stream_cipher</code>:</p>
<table>
<tr><th>Class Name</th><th>Description</th><th>Supported key sizes</th><th>Supported IV/nonce sizes</th></tr>
<tr>
<td><code>chacha20_128</code><br><code>chacha20_256</code><br><code>chacha12_128</code><br><code>chacha12_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant">ChaCha</a></b> cipher (a variant of Salsa20)
<br>including full 20-round version and reduced 12-round version</td><td>128 / 256</td><td>64</td>
</tr>
<tr>
<td><code>hc128</code><br><code>hc256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/HC-256">HC</a></b> cipher (member of eSTREAM portfolio)</td><td>128 / 256</td><td>128 / 256</td>
</tr>
<tr>
<td><code>salsa20_128</code><br><code>salsa20_256</code><br><code>salsa20_12_128</code><br><code>salsa20_12_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Salsa20">Salsa20</a></b> cipher (member of eSTREAM portfolio)
<br>including full 20-round version and reduced 12-round version</td><td>128 / 256</td><td>64</td>
</tr>
<tr>
<td><code>xchacha20_128</code><br><code>xchacha20_256</code><br><code>xchacha12_128</code><br><code>xchacha12_256</code></td>
<td class="descr"><b>XChaCha</b> cipher (a variant of ChaCha with longer nonce)
<br>including full 20-round version and reduced 12-round version</td><td>128 / 256</td><td>192</td>
</tr>
<tr>
<td><code>xsalsa20_128</code><br><code>xsalsa20_256</code><br><code>xsalsa20_12_128</code><br><code>xsalsa20_12_256</code></td>
<td class="descr"><b>XSalsa20</b> cipher (a variant of Salsa20 with longer nonce)
<br>including full 20-round version and reduced 12-round version</td><td>128 / 256</td><td>192</td>
</tr>
</table>
<p>You can also use any of the supported block ciphers like a stream cipher via <code>ctr</code> class, which implements the same <code>stream_cipher</code> interface.</p>
<h3>6.3. Encryption performance</h3>
<table>
<tr><th colspan="7" class="thh left top right">
Performance in megabytes per second (MB/s), higher number means faster<br><i>(measured by encrypting a 130Kb file 100,000 times)</i>
</th></tr>
<tr>
<th rowspan="3" class="left right top bottom">Algorithm</th><th colspan="6" class="left right top">PC: Intel Xeon E5-1650 v3</th>
</tr>
<tr>
<th colspan="2" class="left right">OS: Win7 x64<br>Compiler: VC++2015</th>
<th colspan="2" class="left right">OS: openSUSE (in VM)<br>Compiler: gcc 5.2.1</th>
<th colspan="2" class="left right">OS: openSUSE (in VM)<br>Compiler: clang 3.7.0</th>
</tr>
<tr>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm top">ChaCha20-128</td><td class="top">1200</td><td class="right top">1050</td><td class="top">1286</td><td class="right top">995</td><td class="top">1340</td><td class="right top">1130</td>
<tr><td class="algorithm">ChaCha20-256</td><td>1200</td><td class="right">1050</td><td>1286</td><td class="right">995</td><td>1340</td><td class="right">1130</td>
<tr><td class="algorithm">ChaCha12-128</td><td>1920</td><td class="right">1595</td><td>2070</td><td class="right">1585</td><td>2140</td><td class="right">1795</td>
<tr><td class="algorithm">ChaCha12-256</td><td>1920</td><td class="right">1595</td><td>2070</td><td class="right">1585</td><td>2140</td><td class="right">1795</td>
<tr><td class="algorithm top">HC-128</td><td class="top">1750</td><td class="right top">1350</td><td class="top">1760</td><td class="right top">1550</td><td class="top">1810</td><td class="right top">1965</td>
<tr><td class="algorithm">HC-256</td><td>1050</td><td class="right">825</td><td>1157</td><td class="right">965</td><td>1110</td><td class="right">1095</td>
<tr><td class="algorithm top">Salsa20-128</td><td class="top">1150</td><td class="right top">855</td><td class="top">1100</td><td class="right top">900</td><td class="top">1170</td><td class="right top">1045</td>
<tr><td class="algorithm">Salsa20-256</td><td>1150</td><td class="right">855</td><td>1100</td><td class="right">900</td><td>1170</td><td class="right">1045</td>
<tr><td class="algorithm">Salsa20/12-128</td><td>1835</td><td class="right">1310</td><td>1750</td><td class="right">1410</td><td>1850</td><td class="right">1660</td>
<tr><td class="algorithm">Salsa20/12-256</td><td>1835</td><td class="right">1310</td><td>1750</td><td class="right">1410</td><td>1850</td><td class="right">1660</td>
<tr><td class="algorithm top">XChaCha20-128</td><td class="top">1200</td><td class="right top">1050</td><td class="top">1286</td><td class="right top">995</td><td class="top">1340</td><td class="right top">1130</td>
<tr><td class="algorithm">XChaCha20-256</td><td>1200</td><td class="right">1050</td><td>1286</td><td class="right">995</td><td>1340</td><td class="right">1130</td>
<tr><td class="algorithm">XChaCha12-128</td><td>1920</td><td class="right">1595</td><td>2070</td><td class="right">1585</td><td>2140</td><td class="right">1795</td>
<tr><td class="algorithm bottom">XChaCha12-256</td><td class="bottom">1920</td><td class="right bottom">1595</td><td class="bottom">2070</td><td class="right bottom">1585</td><td class="bottom">2140</td><td class="right bottom">1795</td>
<tr><td class="algorithm top">XSalsa20-128</td><td class="top">1150</td><td class="right top">855</td><td class="top">1100</td><td class="right top">900</td><td class="top">1170</td><td class="right top">1045</td>
<tr><td class="algorithm">XSalsa20-256</td><td>1150</td><td class="right">855</td><td>1100</td><td class="right">900</td><td>1170</td><td class="right">1045</td>
<tr><td class="algorithm">XSalsa20/12-128</td><td>1835</td><td class="right">1310</td><td>1750</td><td class="right">1410</td><td>1850</td><td class="right">1660</td>
<tr><td class="algorithm bottom">XSalsa20/12-256</td><td class="bottom">1835</td><td class="right bottom">1310</td><td class="bottom">1750</td><td class="right bottom">1410</td><td class="bottom">1850</td><td class="right bottom">1660</td>
</table>
<p>You can run the stream cipher encryption performance test on your own PC using the following command:</p>
<pre>    digest sctest &lt;number_of_iterations&gt; &lt;filename_to_encrypt&gt;</pre>
<h2 id="chkdf">7. Key derivation functions</h2>
<h3>7.1. PBKDF2</h3>
<p>Function <a href="https://en.wikipedia.org/wiki/PBKDF2">pbkdf2</a> has the following prototype:</p>
<pre>
    void pbkdf2(hmac& hmac, const unsigned char* salt, size_t salt_len, int iterations, unsigned char* dk, size_t dklen);
</pre>
<p>You can use this function to derive an encryption key from a password. The password should be passed to the constructor of <code>hmac</code> object as the key.</p>
<p>The following snippet generates a 256-bit key from password "password" and salt "salt" using PBKDF2 algorithm with 100000 iterations of HMAC-SHA256:</p>
<pre>
    hmac hmac(sha256(), "password");
    unsigned char key[256 / 8];
    pbkdf2(hmac, (const unsigned char*)"salt", 4, 100000, key, sizeof(key));
</pre>
<h3>7.2. scrypt</h3>
<p>Function <a href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a> has the following prototype:</p>
<pre>
<i>    /*
    scrypt key derivation function.

    Input:
    hmac    HMAC to use (e.g. HMAC-SHA-256). The password shall be passed to the constructor of hmac object.
    salt    Salt.
    N       CPU/Memory cost parameter, must be larger than 1, a power of 2 and less than 2<sup>16*r</sup>.
    r       Block size factor parameter.
    p       Parallelization parameter, a positive integer less than 2<sup>30</sup>/r.
    dklen   Intended output length of the derived key; a positive integer less than or equal to (2<sup>32</sup> - 1) * 32.

    Output:
    dk      Derived key, of length dklen bytes.
    */</i>

    void scrypt(hmac& hmac, const unsigned char* salt, size_t salt_len, size_t N, size_t r, size_t p, unsigned char* dk, size_t dklen);
</pre>
<p>You can use this function to derive an encryption key from a password. The password should be passed to the constructor of <code>hmac</code> object as the key.</p>
<p>The following snippet generates a 256-bit key from password "password" and salt "salt" using scrypt with N=16384, r=8 and p=16 (which takes 0.10 seconds on Intel Xeon E5-1650 v3):</p>
<pre>
    hmac hmac(sha256(), "password");
    unsigned char key[256 / 8];
    scrypt(hmac, (const unsigned char*)"salt", 4, 16384, 8, 16, key, sizeof(key));
</pre>
<h3>7.3. Argon2</h3>
<p><a href="https://en.wikipedia.org/wiki/Argon2">Argon2</a> is a winner of Password Hashing Competition and is the recommended function for hashing passwords.</p>
<p>There are three versions of Argon2 function: <code>argon2i</code>, <code>argon2d</code> and <code>argon2id</code>. Argon2i is the safest against side-channel attacks, while Argon2d provides the highest resistance against GPU cracking attacks.</p>
<pre><i>    /*
    Argon2 key derivation function.

    Input:
    password Passphrase.
    salt     Salt.
    p        A parallelism degree, which defines the number of parallel threads.
    m        A memory cost, which defines the memory usage, given in kibibytes.
    t        A time cost, which defines the amount of computation realized and therefore the execution time, given in number of iterations.
    dklen    Intended output length of the derived key, given in bytes.

    Optional input:
    data     Associated data which will affect the derived key.
    secret   Secret value which will affect the derived key.
    version  Version of the algorithm (argon2_version::version12 is supported for compatibility, for new development use the latest argon2_version::version13).

    Output:
    dk       Derived key, of length dklen bytes.
    */</i>

    void argon2d(const char* password, uint32_t pwd_len, const unsigned char* salt, uint32_t salt_len,
                 uint32_t p, uint32_t m, uint32_t t, unsigned char* dk, uint32_t dklen,
                 unsigned char* data = nullptr, uint32_t datalen = 0, unsigned char* secret = nullptr, uint32_t secretlen = 0,
                 argon2_version version = argon2_version::version13);

    void argon2i(const char* password, uint32_t pwd_len, const unsigned char* salt, uint32_t salt_len,
                 uint32_t p, uint32_t m, uint32_t t, unsigned char* dk, uint32_t dklen,
                 unsigned char* data = nullptr, uint32_t datalen = 0, unsigned char* secret = nullptr, uint32_t secretlen = 0,
                 argon2_version version = argon2_version::version13);

    void argon2id(const char* password, uint32_t pwd_len, const unsigned char* salt, uint32_t salt_len,
                  uint32_t p, uint32_t m, uint32_t t, unsigned char* dk, uint32_t dklen,
                  unsigned char* data = nullptr, uint32_t datalen = 0, unsigned char* secret = nullptr, uint32_t secretlen = 0,
                  argon2_version version = argon2_version::version13);
</pre>
<p>The following snippet generates a 256-bit key from password "password" and salt "salt" using <code>argon2i</code> function with p=4, m=4096 and t=1000 (which takes 0.68 seconds on Intel Xeon E5-1650 v3):</p>
<pre>
    unsigned char key[256 / 8];
    argon2i("password", 8, (const unsigned char*)"salt", 4, 4, 4096, 1000, key, sizeof(key));
</pre>
<p>Our implementation of Argon2 is faster than the optimized reference implementation, which needs 1.05 seconds to compute the same Argon2i hash on the same PC (both implementations were compiled by VC++ 2015 with /O2 optimization).</p>
<h2 id="chdu">8. Digest utility</h2>
<p>Also included is a command-line utility 'digest.exe' which can be used to calculate message digest of any file(s) using any of the supported hash algorithms (similar to md5sum), for example, if you want to calculate
Skein-512/256 hash of a file, you can run:</p>
<pre>
   digest skein512/256 file.ext
</pre
<p>You can save the checksums to a text file using the following command:</p>
<pre>
   digest skein512/256 * > checksums.skein
</pre
<p>Like md5sum, the utility can also verify checksums saved in a file, for example, if you want to verify the hashes saved
by the previous command, you can run:</p>
<pre>
   digest -c skein512/256 checksums.skein
</pre>
<h2 id="chcryptor">9. Cryptor utility</h2>
<p>Command-line utility 'cryptor.exe' is intended to demonstrate how cppcrypto library can be utilized to encrypt or decrypt a file.
To encrypt a file, run:</p>
<pre>
   cryptor enc file.ext
</pre>
<p>To decrypt a file, run:</p>
<pre>
   cryptor dec file.ext
</pre>
<p>The utility demonstrates the steps needed for encryption:<p>
<ul><li>Generate random salt and initialization vector.</li>
<li>Ask for a password and derive keys for encryption and authentication using argon2d key derivation function.</li>
<li>Encrypt a file using Serpent algorithm with 256-bit key in CBC mode.</li>
<li>Authenticate the encryption using HMAC-Gr√∏stl-256.</li>
</ul>
<p>The utility is provided mainly for demonstration purposes, algorithm choice is arbitrary.</p>
<h2 id="chpn">10. Portability notes</h2>
<p>At the moment we support only x86 processors (in 32-bit or 64-bit mode).
<br>To build cppcrypto from the sources you need to have yasm installed.
<br>We have successfully compiled and tested cppcrypto under the following operating systems.</p>
<h3>10.1. Windows</h3>
<p>Tested OS versions: Windows 7, Windows 10.
<br>Tested compilers: Visual C++ 2013, Visual C++ 2015, Visual C++ 2017.</p>
<p>First, download the latest yasm for Visual Studio and install it according to the instructions in its readme.txt.
Note that the latest stable release of yasm (1.3.0) ships vsyasm.props file which is not compatible with Visual Studio 2013 or later. The fixed version of vsyasm.props is included in the cppcrypto source archive, so you just need to replace that single file. (Alternatively, use the development version of yasm from their git repository, which reportedly fixes the compatibility issue.)</p>
<p>Then, open the supplied Visual C++ project files or solution file and build cppcrypto.
If you're using Visual Studio 2015 or later, right-click each project and choose &quot;Upgrade VC Compilers and Libraries&quot; menu item, since the provided project files are from VS2013.</p>
<p>If you use the precompiled static libraries then you don't need yasm.
Just link against cppcryptomd.lib or cppcryptomt.lib depending on your /MT or /MD settings.
</p>
<p>Experimental support for Cygwin gcc builds has been added recently; to build in cygwin, run 'make UNAME=Cygwin' and 'make UNAME=Cygwin install'.</p>
<h3>10.2. Linux</h3>
<p>Tested OS versions: openSUSE Tumbleweed (x86_64 and i586), Debian Sid (x86_64), Fedora 23 (x86_64).<br>
Tested compilers: gcc 5.1.1, gcc 5.2.1, gcc 7.1.1, clang 3.7.0, clang 4.0.1.</p>
<p>Make sure yasm is installed, then run make and [sudo] make install as usual.</p>
<p>Note that if you do not use recent versions of libstdc++ and try to run the vectortest.sh script on Linux, you may get a crash during checking sha384 and sha512 test vectors. This is caused by a bug in libstdc++ (stack overflow on long regexes), which is fixed in latest versions. This bug does not affect the functionality of cppcrypto library anyhow, C++ regexes are only used in the test application for parsing the test vectors.</p>
<h3>10.3. Mac OS X</h3>
<p>Tested OS versions: OS X 10.11.1 El Capitan.
<br>Tested compilers: Apple LLVM version 7.0.0 (clang-700.1.76).</p>
<p>Download and install yasm. Then run make and [sudo] make install to build and install cppcrypto.</p>
<h3>10.4. FreeBSD</h3>
<p>Tested OS versions: FreeBSD 10.2-RELEASE.
<br>Tested compilers: clang 3.4.1.</p>
<p>Install yasm (pkg install yasm) and GNU make (pkg install gmake). Then, run gmake and [sudo] gmake install to build and install cppcrypto.</p>
<h3>10.5. Solaris</h3>
<p>Tested OS versions: Solaris 11.3.
<br>Tested compilers: Solaris Studio 12.4.</p>
<p>Install yasm from OpenCSW. Be sure yasm, gmake, ginstall and Solaris Studio compiler (CC) are in the PATH. Then, run gmake and [sudo] gmake install to build and install cppcrypto.</p>
<h2 id="chdl">11. Download link</h2>
<p><a href="https://sourceforge.net/projects/cppcrypto/files">Download cppcrypto from sourceforge</a></p>
<p></p>
